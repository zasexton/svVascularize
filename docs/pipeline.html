<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>svVascularize Quickstart</title>
  <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet" />
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <header class="topnav">
    <div class="container">
      <h1><a href="index.html">svVascularize</a></h1>
      <nav>
        <a href="index.html#about">About</a>
        <a href="install.html">Installation</a>
        <a href="doc.html">Documentation</a>
        <a href="index.html#simulation">Simulation</a>
        <a href="https://pypi.org/project/svv/" target="_blank" rel="noopener">PyPI</a>
        <a href="https://github.com/SimVascular/svVascularize" target="_blank" rel="noopener">GitHub</a>
      </nav>
    </div>
  </header>

 <main class="container content">
     <h2>End-to-End Pipeline for 3D CFD Simulations</h2>
     <p> Generating a watertight, simulation-ready finite element mesh for computational fluid dynamics is a challenging
         multi-step problem. For typical workflows modeling bloodflow from clinical imaging data, this process involves
         pathline generation, segmentation, solid surface creation, volume mesh generation, mesh optimization/smoothing,
         and boundary identification. The pathline and segmentation steps are dependent upon available image data, thus
         these steps are very different for synthetically generated vascular structures which inheriently lack imaging
         data. The remaining steps are somewhat the same except that the workflow employed with
         <code>svVascularize</code> is automated since the number of vessels may quickly exceed practical manual
         efforts for model and mesh creation. These automated steps are all part of the <code>Simulation</code> class
         which can be used to wrap around synthetic vascular objects in order to build simulation files. We will
         demonstrate the basic API below for a simple vascular tree. </p>
     <pre data-copy> <code class="language-python">import pyvista as pv
 from svv.domain.domain import Domain
 from svv.tree.tree import Tree
 from svv.simulation.simulation import Simulation

 cube = Domain(pv.Cube())
 cube.create()
 cube.solve()
 cube.build()

 t = Tree()
 t.set_domain(cube)
 t.set_root()
 t.n_add(2)</code></pre>
     <p> Now that we have a simple tree we can start building simulations from this object. </p>
     <pre data-copy> <code class="language-python"># Create Simulation Container for Synthetic Tree Object
 sim = Simulation(t)

 # Build All Surface/Volume Meshes for 3D CFD Simulation
 sim.build_meshes()</code></pre>
     <p>This method will produce unioned surface <code>.vtp</code> meshes and their cooresponding volume meshes <code>.vtu</code>
         representing the synthetic vascular object. Additionally, the procedure will attempt to append boundary layer meshes
         along the walls vessels, typical in many hemodynamic studies to account for the steep velocity gradients near vessel
         walls. If successful, the surfaces meshes will be stored within the simulation container list
         <code>simulation.fluid_domain_surface_meshes</code>, volume meshes will be stored within the container
         <code>simulation.fluid_domain_volume_meshes</code>, and boundary layers will be stored within the container
         <code>simulation.fluid_domain_boundary_layers</code>. Storing the meshes as python objects allows for more custom
         modification procedures that users may want to implement prior to creating the simulation files.
     </p>
     <div class="callout"><strong>Mesh building: </strong> This step is potentially memory and compute intensive depending
         on the size of the synthetic vascular object being discretized. Under the hood, <code>svVascularize</code> is
         using a combination of <code>tetgen</code> and <code>mmg</code> meshing utilities via python subprocess calls.
         These, as well as surface mesh unioning operations, are non-trivial and may take minutes-hours to complete.
         Users can supply custom meshing parameters for their applications to override default values this may result
         in more efficient meshing, but it is recommended that default parameters are attemped first.</div>
     <p>Once meshes exist, identify wall and outlet patches that become boundary conditions. The
         <code>Simulation.extract_faces()</code> routine wraps <code>svv.simulation.utils.extract_faces</code> to label
         surfaces on both the solid model and the tetrahedral mesh.</p>
     <pre data-copy> <code class="language-python"># Detect walls, outlets, and shared boundaries
sim.extract_faces(crease_angle=60.0)

# Inspect names stored in the GeneralMesh container
print(sim.fluid_domain_meshes[0].faces.keys())</code></pre>
     <p>Finally, assemble the svFSI configuration and write everything to disk. The default output directory is created if
         it does not exist.</p>
     <pre data-copy> <code class="language-python"># Build and persist 3-D CFD input files
sim.construct_3d_fluid_simulation()
sim.write_3d_fluid_simulation()

# Result: meshes + XML under sim.file_path (e.g. ./simulations/example/)</code></pre>
     <div class="callout info"><strong>Directory layout:</strong> The export creates a <code>mesh/</code> folder containing
         the volume grid (<code>.vtu</code> or <code>.vtp</code>), a <code>mesh-surfaces/</code> folder for each named face, and
         a <code>fluid_simulation_0-0.xml</code> svFSI input file.</div>
     <p>For rapid prototyping, couple the same tree to the reduced-order solvers shipped with SimVascular.</p>
     <pre data-copy> <code class="language-python">from svv.simulation.fluid.rom.zero_d.zerod_tree import export_0d_simulation

export_0d_simulation(t, outdir=sim.file_path + "/rom_0d")

# Optionally stage 1-D parameters for multi-scale workflows
sim.construct_1d_fluid_simulation(time_step_size=1e-3, number_time_steps=2000)</code></pre>
     <div class="callout warning"><strong>Note:</strong> Writing of 1-D files is not yet automated. The parameter bundle
         returned by <code>construct_1d_fluid_simulation()</code> can be passed to the SimVascular 1-D solver tools.</div>
 </main>
  <footer>
    <div class="container">
      <p>&copy; 2025 SimVascular, Stanford University, The Regents of the University of California, and others â€”
      <a href="https://opensource.org/license/BSD-3-Clause">BSD 3-Clause License</a><br></p>
    </div>
  </footer>

  <script defer src="script.js"></script>
</body>
</html>