<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>svv.domain.Patch - svVascularize API</title>
    <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet" />
    <link rel="stylesheet" href="../style.css">
    <link rel="stylesheet" href="style_api.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <!-- Shared top navigation -->
    <header class="topnav">
        <div class="container">
            <h1>svVascularize</h1>
            <nav>
                <a href="../index.html#about">About</a>
                <a href="../install.html">Installation</a>
                <a href="../doc.html">Documentation</a>
                <a href="#simulation">Simulation</a>
                <a href="https://pypi.org/project/svv/" target="_blank" rel="noopener">PyPI</a>
                <a href="https://github.com/SimVascular/svVascularize" target="_blank" rel="noopener">GitHub</a>
            </nav>
        </div>
    </header>

    <!-- Breadcrumbs -->
    <div class="container">
        <nav class="api-breadcrumbs">
            <a href="../doc.html">Documentation</a>
            <span class="separator">/</span>
            <a href="index_api.html">API Reference</a>
            <span class="separator">/</span>
            <a href="index_api.html#module-domain">svv.domain</a>
            <span class="separator">/</span>
            <span>Patch</span>
        </nav>
    </div>

    <!-- Main Content -->
    <div class="container api-container">
        <!-- Class Header -->
        <div class="api-class-header">
            <h1><code>svv.domain.Patch</code></h1>
            <div class="api-badges">
                <span class="api-module-badge">Domain Component</span>
                <span class="api-version-badge">v1.0.0</span>
            </div>
        </div>

        <!-- Class Description -->
        <div class="api-class-description">
            <p>
                The Patch class decomposes a domain into a set of interpolation sub-problems which
                can be solved independently and then blended together to form the final
                domain interpolation function.
            </p>
            <p>
                Each patch represents a local region of the domain where radial basis function (RBF)
                interpolation is performed. Patches are the fundamental building blocks that enable
                efficient implicit function construction for complex geometries.
            </p>
        </div>

        <!-- Quick Example -->
        <div class="api-quick-example">
            <h2>Quick Example</h2>
            <pre data-copy><code class="language-python">import numpy as np
from svv.domain.patch import Patch

# Create a patch with points and normals
points = np.array([[0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1]])
normals = np.array([[0, 0, 1], [0, 0, 1], [0, 0, 1], [0, 0, 1]])

# Initialize patch with regularization parameter
patch = Patch(lam=0.01)

# Set data
patch.set_data(points, normals)

# Solve the interpolation problem
patch.solve(method="L-BFGS-B", precision=9)

# Build the interpolation function
interpolation_func = patch.build()

# Evaluate at new points
test_points = np.array([[0.5, 0.5, 0]])
values = interpolation_func(test_points)</code></pre>
        </div>

        <!-- Main Documentation Grid -->
        <div class="api-grid">
            <!-- Left Navigation -->
            <aside class="api-sidebar">
                <div class="sidebar-section">
                    <h4 class="sidebar-title">Contents</h4>
                    <nav class="api-sidebar-nav">
                        <ul>
                            <li><a href="#constructor"><i class="fas fa-hammer"></i> Constructor</a></li>
                            <li><a href="#attributes"><i class="fas fa-database"></i> Attributes</a></li>
                            <li><a href="#methods"><i class="fas fa-cogs"></i> Methods</a></li>
                            <li><a href="#interpolation"><i class="fas fa-wave-square"></i> Interpolation Function</a></li>
                            <li><a href="#examples"><i class="fas fa-code"></i> Examples</a></li>
                            <li><a href="#theory"><i class="fas fa-graduation-cap"></i> Theory</a></li>
                        </ul>
                    </nav>
                </div>
            </aside>

            <!-- Main Content -->
            <main class="api-main-content">
                <!-- Constructor Section -->
                <section id="constructor" class="api-section">
                    <h2>Constructor</h2>

                    <div class="api-signature">
                        <code>Patch(lam=0)</code>
                    </div>

                    <div class="api-parameters">
                        <h3>Parameters</h3>
                        <table class="api-table">
                            <thead>
                                <tr>
                                    <th>Parameter</th>
                                    <th>Type</th>
                                    <th>Default</th>
                                    <th>Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>lam</code></td>
                                    <td>float</td>
                                    <td>0</td>
                                    <td>Regularization parameter (lambda) for the RBF interpolation. Higher values provide more smoothing.</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </section>

                <!-- Attributes Section -->
                <section id="attributes" class="api-section">
                    <h2>Attributes</h2>

                    <table class="api-table">
                        <thead>
                            <tr>
                                <th>Attribute</th>
                                <th>Type</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>points</code></td>
                                <td>np.ndarray</td>
                                <td>Points defining the patch (n×d array)</td>
                            </tr>
                            <tr>
                                <td><code>normals</code></td>
                                <td>np.ndarray</td>
                                <td>Normal vectors at each point (n×d array, optional)</td>
                            </tr>
                            <tr>
                                <td><code>kernel</code></td>
                                <td>Kernel</td>
                                <td>Kernel object for RBF calculations</td>
                            </tr>
                            <tr>
                                <td><code>solver</code></td>
                                <td>Solver</td>
                                <td>Optimization solver for finding RBF coefficients</td>
                            </tr>
                            <tr>
                                <td><code>constants</code></td>
                                <td>np.ndarray</td>
                                <td>Solved coefficients for the interpolation function</td>
                            </tr>
                            <tr>
                                <td><code>rbf_degree</code></td>
                                <td>int</td>
                                <td>Degree of the RBF (default: 3 for Duchon's thin-plate spline)</td>
                            </tr>
                            <tr>
                                <td><code>lam</code></td>
                                <td>float</td>
                                <td>Regularization parameter</td>
                            </tr>
                        </tbody>
                    </table>
                </section>

                <!-- Methods Section -->
                <section id="methods" class="api-section">
                    <h2>Methods</h2>

                    <div class="api-method">
                        <div class="api-method-signature">
                            <code>set_data(*args)</code>
                        </div>
                        <p>Set the point cloud data for the patch.</p>
                        <div class="api-method-params">
                            <h4>Parameters</h4>
                            <ul>
                                <li><code>*args</code>: Variable arguments
                                    <ul>
                                        <li>Single argument: points array (n×d)</li>
                                        <li>Two arguments: points array (n×d) and normals array (n×d)</li>
                                    </ul>
                                </li>
                            </ul>
                            <h4>Notes</h4>
                            <p>When normals are provided, they are used as initial values for the kernel, improving convergence and accuracy of the interpolation.</p>
                        </div>
                    </div>

                    <div class="api-method">
                        <div class="api-method-signature">
                            <code>solve(method="L-BFGS-B", precision=9)</code>
                        </div>
                        <p>Solve the interpolation problem to find optimal RBF coefficients.</p>
                        <div class="api-method-params">
                            <h4>Parameters</h4>
                            <ul>
                                <li><code>method</code> (str, default="L-BFGS-B"): Optimization method
                                    <ul>
                                        <li>"L-BFGS-B": Limited-memory Broyden-Fletcher-Goldfarb-Shanno Bounded</li>
                                        <li>Other scipy.optimize methods are supported</li>
                                    </ul>
                                </li>
                                <li><code>precision</code> (int, default=9): Number of decimal places to round the constants</li>
                            </ul>
                            <h4>Notes</h4>
                            <p>The solver automatically skips normal estimation if normals were provided in <code>set_data()</code>.</p>
                        </div>
                    </div>

                    <div class="api-method">
                        <div class="api-method-signature">
                            <code>build()</code>
                        </div>
                        <p>Build and return the interpolation function for the patch.</p>
                        <div class="api-method-params">
                            <h4>Returns</h4>
                            <ul>
                                <li><code>f</code> (callable): Interpolation function with signature <code>f(x)</code> where x is an array of points</li>
                            </ul>
                            <h4>Function Attributes</h4>
                            <p>The returned function has the following attributes:</p>
                            <ul>
                                <li><code>points</code>: Original patch points</li>
                                <li><code>normals</code>: Surface normals (provided or computed)</li>
                                <li><code>dimensions</code>: Spatial dimension</li>
                                <li><code>min</code>, <code>max</code>: Bounding box</li>
                                <li><code>centroid</code>: Center of the patch</li>
                                <li><code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>: RBF coefficients</li>
                            </ul>
                        </div>
                    </div>
                </section>

                <!-- Interpolation Function Section -->
                <section id="interpolation" class="api-section">
                    <h2>Interpolation Function</h2>

                    <p>The interpolation function returned by <code>build()</code> evaluates the implicit function at given points using Duchon's thin-plate spline formulation:</p>

                    <div class="api-equation">
                        <pre><code>f(x) = Σᵢ aᵢ φ(||x - pᵢ||) + Σᵢ bᵢ · ∇φ(||x - pᵢ||) + c · x + d</code></pre>
                    </div>

                    <p>Where:</p>
                    <ul>
                        <li><code>φ(r) = r³</code> is the RBF kernel (cubic for 3D)</li>
                        <li><code>aᵢ</code> are the RBF coefficients</li>
                        <li><code>bᵢ</code> are gradient coefficients (when normals are used)</li>
                        <li><code>c</code> and <code>d</code> define the polynomial trend</li>
                        <li><code>pᵢ</code> are the patch points</li>
                    </ul>

                    <div class="api-method">
                        <div class="api-method-signature">
                            <code>f(x, show=False)</code>
                        </div>
                        <p>Evaluate the interpolation at given points.</p>
                        <div class="api-method-params">
                            <h4>Parameters</h4>
                            <ul>
                                <li><code>x</code> (np.ndarray): Points to evaluate (m×d array)</li>
                                <li><code>show</code> (bool, default=False): Print debug information during evaluation</li>
                            </ul>
                            <h4>Returns</h4>
                            <ul>
                                <li><code>values</code> (np.ndarray): Interpolated values at the points</li>
                            </ul>
                        </div>
                    </div>
                </section>

                <!-- Examples Section -->
                <section id="examples" class="api-section">
                    <h2>Examples</h2>

                    <div class="api-example">
                        <h3>Basic Patch Interpolation</h3>
                        <pre data-copy><code class="language-python">import numpy as np
from svv.domain.patch import Patch

# Create sample points on a sphere
theta = np.linspace(0, np.pi, 10)
phi = np.linspace(0, 2*np.pi, 10)
theta, phi = np.meshgrid(theta, phi)
x = np.sin(theta.ravel()) * np.cos(phi.ravel())
y = np.sin(theta.ravel()) * np.sin(phi.ravel())
z = np.cos(theta.ravel())
points = np.column_stack((x, y, z))

# Create patch
patch = Patch(lam=0.001)
patch.set_data(points)

# Solve interpolation
patch.solve()

# Build function
f = patch.build()

# Test interpolation
test_pt = np.array([[0.5, 0.5, 0.5]])
value = f(test_pt)
print(f"Interpolated value: {value[0]:.4f}")</code></pre>
                    </div>

                    <div class="api-example">
                        <h3>Patch with Normal Constraints</h3>
                        <pre data-copy><code class="language-python"># Points and normals from a surface
points = np.array([
    [0, 0, 0],
    [1, 0, 0.1],
    [0, 1, 0.1],
    [1, 1, 0.2]
])

# Normals pointing upward with slight variation
normals = np.array([
    [0, 0, 1],
    [0.1, 0, 0.99],
    [0, 0.1, 0.99],
    [0.1, 0.1, 0.98]
])

# Normalize the normals
normals = normals / np.linalg.norm(normals, axis=1, keepdims=True)

# Create patch with normal constraints
patch = Patch(lam=0.01)
patch.set_data(points, normals)

# Solve with high precision
patch.solve(method="L-BFGS-B", precision=12)

# Build and evaluate
f = patch.build()

# Create a grid for visualization
xx, yy = np.meshgrid(np.linspace(-0.5, 1.5, 20),
                     np.linspace(-0.5, 1.5, 20))
zz = np.zeros_like(xx)
grid_points = np.column_stack((xx.ravel(), yy.ravel(), zz.ravel()))

# Evaluate on grid
values = np.array([f(pt.reshape(1, -1))[0] for pt in grid_points])
values = values.reshape(xx.shape)

print(f"Min value: {values.min():.4f}")
print(f"Max value: {values.max():.4f}")</code></pre>
                    </div>

                    <div class="api-example">
                        <h3>Accessing Interpolation Coefficients</h3>
                        <pre data-copy><code class="language-python"># Create and solve a patch
patch = Patch(lam=0.0)
patch.set_data(points, normals)
patch.solve()

# Build function
f = patch.build()

# Access the RBF coefficients
print(f"RBF coefficients (a): {f.a.shape}")
print(f"Gradient coefficients (b): {f.b.shape}")
print(f"Linear coefficients (c): {f.c}")
print(f"Constant term (d): {f.d}")

# Access patch properties
print(f"Patch centroid: {f.centroid}")
print(f"Bounding box: [{f.min}, {f.max}]")
print(f"Dimensions: {f.dimensions}D")</code></pre>
                    </div>
                </section>

                <!-- Theory Section -->
                <section id="theory" class="api-section">
                    <h2>Theory</h2>

                    <div class="admonition info">
                        <p><strong>Radial Basis Functions:</strong> The Patch class uses Duchon's thin-plate splines as the radial basis function. For 3D problems, this corresponds to φ(r) = r³, which provides C² continuity and minimal bending energy.</p>
                    </div>

                    <div class="admonition note">
                        <p><strong>Hermite Interpolation:</strong> When normals are provided, the patch performs Hermite interpolation, matching both function values and derivatives at the data points. This results in more accurate surface representation.</p>
                    </div>

                    <div class="admonition warning">
                        <p><strong>Regularization:</strong> The <code>lam</code> parameter controls the trade-off between interpolation accuracy and smoothness. Small values (near 0) give exact interpolation but may oscillate. Larger values provide smoother results but may not pass exactly through the data points.</p>
                    </div>

                    <h3>Mathematical Formulation</h3>
                    <p>The patch solves the following optimization problem:</p>
                    <pre><code>min ||Kc - f||² + λ||c||²</code></pre>
                    <p>Where:</p>
                    <ul>
                        <li><code>K</code> is the kernel matrix</li>
                        <li><code>c</code> are the coefficients to be found</li>
                        <li><code>f</code> are the target values (zeros for implicit surface)</li>
                        <li><code>λ</code> is the regularization parameter</li>
                    </ul>
                </section>

                <!-- See Also Section -->
                <section class="api-section">
                    <h2>See Also</h2>
                    <ul>
                        <li><a href="domain.html"><code>svv.domain.Domain</code></a> - Main domain class that uses patches</li>
                        <!-- <li><a href="kernel.html"><code>svv.domain.kernel.Kernel</code></a> - Kernel computation for RBF</li>
                        <li><a href="solver.html"><code>svv.domain.solver.Solver</code></a> - Optimization solver for patches</li> -->
                    </ul>
                </section>
            </main>

            <!-- Right TOC -->
            <aside class="api-toc-sidebar">
                <div class="sidebar-section">
                    <h4 class="sidebar-title">On This Page</h4>
                    <nav id="local-toc" class="api-local-toc">
                        <!-- Auto-populated by JavaScript -->
                    </nav>
                </div>
            </aside>
        </div>
    </div>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2025 SimVascular, Stanford University, The Regents of the University of California, and others –
            <a href="https://opensource.org/license/BSD-3-Clause">BSD 3-Clause License</a><br></p>
        </div>
    </footer>

    <!-- Additional styles for this page -->
    <style>
        .api-class-header {
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 3px solid var(--clr-primary-400);
        }

        .api-class-header h1 {
            margin: 0;
            font-family: Consolas, monospace;
            color: var(--clr-primary-700);
        }

        .api-badges {
            margin-top: 0.5rem;
            display: flex;
            gap: 0.5rem;
        }

        .api-class-description {
            background: var(--clr-grey-100);
            border-left: 4px solid var(--clr-primary-400);
            padding: 1rem;
            border-radius: var(--radius-sm);
            margin-bottom: 2rem;
        }

        .api-method {
            background: var(--clr-surface);
            border: 1px solid var(--clr-grey-300);
            border-radius: var(--radius-sm);
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .api-method-signature {
            background: var(--clr-grey-100);
            padding: 0.5rem 1rem;
            border-radius: var(--radius-sm);
            font-family: Consolas, monospace;
            margin-bottom: 0.75rem;
        }

        .api-method-params h4 {
            color: var(--clr-primary-700);
            font-size: 0.9rem;
            margin-top: 0.75rem;
            margin-bottom: 0.5rem;
        }

        .api-equation {
            background: var(--clr-grey-100);
            border: 1px solid var(--clr-grey-300);
            border-radius: var(--radius-sm);
            padding: 1rem;
            margin: 1rem 0;
            text-align: center;
            font-family: Consolas, monospace;
        }
    </style>

    <!-- Load Scripts -->
    <script defer src="../script.js"></script>
    <script defer src="script_api.js"></script>
</body>
</html>