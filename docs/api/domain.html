<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>svv.domain.Domain - svVascularize API</title>
    <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet" />
    <link rel="stylesheet" href="../style.css">
    <link rel="stylesheet" href="style_api.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <!-- Shared top navigation -->
    <header class="topnav">
        <div class="container">
            <h1>svVascularize</h1>
            <nav>
                <a href="../index.html#about">About</a>
                <a href="../install.html">Installation</a>
                <a href="../doc.html">Documentation</a>
                <a href="#simulation">Simulation</a>
                <a href="https://pypi.org/project/svv/" target="_blank" rel="noopener">PyPI</a>
                <a href="https://github.com/SimVascular/svVascularize" target="_blank" rel="noopener">GitHub</a>
            </nav>
        </div>
    </header>

    <!-- Breadcrumbs -->
    <div class="container">
        <nav class="api-breadcrumbs">
            <a href="../doc.html">Documentation</a>
            <span class="separator">/</span>
            <a href="index_api.html">API Reference</a>
            <span class="separator">/</span>
            <a href="index_api.html#module-domain">svv.domain</a>
            <span class="separator">/</span>
            <span>Domain</span>
        </nav>
    </div>

    <!-- Main Content -->
    <div class="container api-container">
        <!-- Class Header -->
        <div class="api-class-header">
            <h1><code>svv.domain.Domain</code></h1>
            <div class="api-badges">
                <span class="api-module-badge">Core Class</span>
                <span class="api-version-badge">v1.0.0</span>
            </div>
        </div>

        <!-- Class Description -->
        <div class="api-class-description">
            <p>
                The Domain class defines the region in space that will be recognized by svVascularize when generating
                vascular networks. The class abstracts the physical representation of the space to allow for efficient
                interrogation and data manipulation.
            </p>
            <p>
                Domains can be created from point clouds, PyVista objects, or by combining existing domains using
                set operations. The class provides implicit function evaluation, boundary extraction, and interior
                mesh generation capabilities.
            </p>
        </div>

        <!-- Quick Example -->
        <div class="api-quick-example">
            <h2>Quick Example</h2>
            <pre data-copy><code class="language-python">import numpy as np
import pyvista as pv
from svv.domain import Domain

# Create domain from PyVista mesh
mesh = pv.read('vessel_geometry.stl')
domain = Domain(mesh)

# Build implicit function
domain.create()
domain.solve()
domain.build(resolution=25)

# Get boundary and interior mesh
boundary, grid = domain.get_boundary(resolution=30)
interior_mesh = domain.get_interior()

# Sample points from domain
interior_points, _ = domain.get_interior_points(n=1000)
boundary_points = domain.get_boundary_points(n=500)</code></pre>
        </div>

        <!-- Main Documentation Grid -->
        <div class="api-grid">
            <!-- Left Navigation -->
            <aside class="api-sidebar">
                <div class="sidebar-section">
                    <h4 class="sidebar-title">Contents</h4>
                    <nav class="api-sidebar-nav">
                        <ul>
                            <li><a href="#constructor"><i class="fas fa-hammer"></i> Constructor</a></li>
                            <li><a href="#attributes"><i class="fas fa-database"></i> Attributes</a></li>
                            <li><a href="#methods"><i class="fas fa-cogs"></i> Methods</a></li>
                            <li><a href="#operators"><i class="fas fa-calculator"></i> Operators</a></li>
                            <li><a href="#examples"><i class="fas fa-code"></i> Examples</a></li>
                            <li><a href="#notes"><i class="fas fa-info-circle"></i> Notes</a></li>
                        </ul>
                    </nav>
                </div>
            </aside>

            <!-- Main Content -->
            <main class="api-main-content">
                <!-- Constructor Section -->
                <section id="constructor" class="api-section">
                    <h2>Constructor</h2>

                    <div class="api-signature">
                        <code>Domain(*args, **kwargs)</code>
                    </div>

                    <div class="api-parameters">
                        <h3>Parameters</h3>
                        <table class="api-table">
                            <thead>
                                <tr>
                                    <th>Parameter</th>
                                    <th>Type</th>
                                    <th>Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>*args</code></td>
                                    <td>variable</td>
                                    <td>
                                        Can be:
                                        <ul>
                                            <li>Single numpy array of points (n×d)</li>
                                            <li>Two numpy arrays: points (n×d) and normals (n×d)</li>
                                            <li>PyVista object (PolyData, UnstructuredGrid, etc.)</li>
                                        </ul>
                                    </td>
                                </tr>
                                <tr>
                                    <td><code>**kwargs</code></td>
                                    <td>dict</td>
                                    <td>Additional keyword arguments passed to data processing methods</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </section>

                <!-- Attributes Section -->
                <section id="attributes" class="api-section">
                    <h2>Attributes</h2>

                    <table class="api-table">
                        <thead>
                            <tr>
                                <th>Attribute</th>
                                <th>Type</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>points</code></td>
                                <td>np.ndarray</td>
                                <td>Point cloud defining the domain (n×d array)</td>
                            </tr>
                            <tr>
                                <td><code>normals</code></td>
                                <td>np.ndarray</td>
                                <td>Normal vectors at each point (n×d array)</td>
                            </tr>
                            <tr>
                                <td><code>boundary</code></td>
                                <td>pv.PolyData</td>
                                <td>Boundary mesh of the domain</td>
                            </tr>
                            <tr>
                                <td><code>mesh</code></td>
                                <td>pv.UnstructuredGrid</td>
                                <td>Interior tetrahedral/triangular mesh</td>
                            </tr>
                            <tr>
                                <td><code>patches</code></td>
                                <td>list</td>
                                <td>List of Patch objects for implicit function</td>
                            </tr>
                            <tr>
                                <td><code>functions</code></td>
                                <td>list</td>
                                <td>List of implicit functions</td>
                            </tr>
                            <tr>
                                <td><code>n</code></td>
                                <td>int</td>
                                <td>Number of points</td>
                            </tr>
                            <tr>
                                <td><code>d</code></td>
                                <td>int</td>
                                <td>Spatial dimension (2 or 3)</td>
                            </tr>
                            <tr>
                                <td><code>characteristic_length</code></td>
                                <td>float</td>
                                <td>Characteristic length scale of the domain</td>
                            </tr>
                            <tr>
                                <td><code>area</code></td>
                                <td>float</td>
                                <td>Surface area (3D) or perimeter (2D)</td>
                            </tr>
                            <tr>
                                <td><code>volume</code></td>
                                <td>float</td>
                                <td>Volume (3D) or area (2D)</td>
                            </tr>
                            <tr>
                                <td><code>convexity</code></td>
                                <td>float</td>
                                <td>Ratio of domain volume to convex hull volume</td>
                            </tr>
                        </tbody>
                    </table>
                </section>

                <!-- Methods Section -->
                <section id="methods" class="api-section">
                    <h2>Methods</h2>

                    <!-- Core Methods -->
                    <div class="api-method-group">
                        <h3>Core Methods</h3>

                        <div class="api-method">
                            <div class="api-method-signature">
                                <code>set_data(*args, **kwargs)</code>
                            </div>
                            <p>Set the data for the domain from point-wise data or a PyVista object.</p>
                            <div class="api-method-params">
                                <h4>Parameters</h4>
                                <ul>
                                    <li><code>*args</code>: Points array, points and normals arrays, or PyVista object</li>
                                    <li><code>**kwargs</code>: Additional processing parameters</li>
                                </ul>
                            </div>
                        </div>

                        <div class="api-method">
                            <div class="api-method-signature">
                                <code>create(**kwargs)</code>
                            </div>
                            <p>Create patches for the domain. This is the first step in building the implicit function.</p>
                            <div class="api-method-params">
                                <h4>Parameters</h4>
                                <ul>
                                    <li><code>**kwargs</code>: Parameters passed to the allocation algorithm</li>
                                </ul>
                            </div>
                        </div>

                        <div class="api-method">
                            <div class="api-method-signature">
                                <code>solve(**kwargs)</code>
                            </div>
                            <p>Solve the individual patch interpolation problems prior to blending.</p>
                        </div>

                        <div class="api-method">
                            <div class="api-method-signature">
                                <code>build(**kwargs)</code>
                            </div>
                            <p>Build the implicit function describing the domain.</p>
                            <div class="api-method-params">
                                <h4>Parameters</h4>
                                <ul>
                                    <li><code>resolution</code> (int, default=25): Grid resolution for boundary extraction</li>
                                    <li><code>skip_boundary</code> (bool, default=False): Skip boundary generation</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <!-- Evaluation Methods -->
                    <div class="api-method-group">
                        <h3>Evaluation Methods</h3>

                        <div class="api-method">
                            <div class="api-method-signature">
                                <code>__call__(points, **kwargs)</code>
                            </div>
                            <p>Evaluate the implicit function at given points.</p>
                            <div class="api-method-params">
                                <h4>Parameters</h4>
                                <ul>
                                    <li><code>points</code> (np.ndarray): Points to evaluate (m×d array)</li>
                                    <li><code>k</code> (int, default=1): Number of nearest patches to consider</li>
                                    <li><code>normalize</code> (bool, default=True): Normalize output values</li>
                                    <li><code>tolerance</code> (float): Tolerance for patch selection</li>
                                </ul>
                                <h4>Returns</h4>
                                <ul>
                                    <li><code>values</code> (np.ndarray): Implicit function values (m×1 array)</li>
                                </ul>
                            </div>
                        </div>

                        <div class="api-method">
                            <div class="api-method-signature">
                                <code>within(points, level=0, **kwargs)</code>
                            </div>
                            <p>Determine if points are within the domain.</p>
                            <div class="api-method-params">
                                <h4>Returns</h4>
                                <ul>
                                    <li><code>inside</code> (np.ndarray): Boolean array indicating if points are inside</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <!-- Mesh Generation Methods -->
                    <div class="api-method-group">
                        <h3>Mesh Generation</h3>

                        <div class="api-method">
                            <div class="api-method-signature">
                                <code>get_boundary(resolution, **kwargs)</code>
                            </div>
                            <p>Extract the boundary surface of the domain.</p>
                            <div class="api-method-params">
                                <h4>Parameters</h4>
                                <ul>
                                    <li><code>resolution</code> (int): Grid resolution for marching cubes/squares</li>
                                    <li><code>get_largest</code> (bool, default=True): Reserved (current implementation always returns the largest connected component)</li>
                                </ul>
                                <h4>Returns</h4>
                                <ul>
                                    <li><code>boundary</code> (pv.PolyData): Boundary mesh</li>
                                    <li><code>grid</code> (pv.ImageData): Volumetric grid used for extraction</li>
                                </ul>
                            </div>
                        </div>

                        <div class="api-method">
                            <div class="api-method-signature">
                                <code>get_interior(verbose=False, **kwargs)</code>
                            </div>
                            <p>Generate tetrahedral (3D) or triangular (2D) mesh of the interior.</p>
                            <div class="api-method-params">
                                <h4>Parameters</h4>
                                <ul>
                                    <li><code>verbose</code> (bool): Print mesh generation progress</li>
                                    <li><code>**kwargs</code>: Parameters passed to TetGen/Triangle</li>
                                </ul>
                                <h4>Returns</h4>
                                <ul>
                                    <li><code>mesh</code> (pv.UnstructuredGrid): Interior mesh</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <!-- Point Sampling Methods -->
                    <div class="api-method-group">
                        <h3>Point Sampling</h3>

                        <div class="api-method">
                            <div class="api-method-signature">
                                <code>get_interior_points(n, tree=None, volume_threshold=None, threshold=None, method=None, implicit_range=(-1.0, 0.0), **kwargs)</code>
                            </div>
                            <p>Sample random points from the domain interior.</p>
                            <div class="api-method-params">
                                <h4>Parameters</h4>
                                <ul>
                                    <li><code>n</code> (int): Number of points to sample</li>
                                    <li><code>tree</code> (KDTree, optional): Existing tree structure for collision detection</li>
                                    <li><code>volume_threshold</code> (float, optional): Maximum distance from tree</li>
                                    <li><code>threshold</code> (float, optional): Minimum distance from tree</li>
                                    <li><code>method</code> (str, optional): Sampling method ('implicit_only', 'preallocate', or default)</li>
                                    <li><code>implicit_range</code> (tuple): Range of implicit function values to accept</li>
                                </ul>
                                <h4>Returns</h4>
                                <ul>
                                    <li><code>points</code> (np.ndarray): Sampled points (n×d array)</li>
                                    <li><code>cells</code> (np.ndarray): Cell indices for each point</li>
                                </ul>
                            </div>
                        </div>

                        <div class="api-method">
                            <div class="api-method-signature">
                                <code>get_boundary_points(n, method=None, **kwargs)</code>
                            </div>
                            <p>Sample random points from the domain boundary.</p>
                            <div class="api-method-params">
                                <h4>Parameters</h4>
                                <ul>
                                    <li><code>n</code> (int): Number of points to sample</li>
                                    <li><code>method</code> (str, optional): Sampling method</li>
                                </ul>
                                <h4>Returns</h4>
                                <ul>
                                    <li><code>points</code> (np.ndarray): Sampled boundary points (n×d array)</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <!-- Utility Methods -->
                    <div class="api-method-group">
                        <h3>Utility Methods</h3>

                        <div class="api-method">
                            <div class="api-method-signature">
                                <code>set_random_seed(seed)</code>
                            </div>
                            <p>Set the random seed for reproducible sampling.</p>
                        </div>

                        <div class="api-method">
                            <div class="api-method-signature">
                                <code>set_random_generator()</code>
                            </div>
                            <p>Initialize the random number generator with the set seed.</p>
                        </div>
                    </div>
                </section>

                <!-- Operators Section -->
                <section id="operators" class="api-section">
                    <h2>Operators</h2>

                    <div class="api-operator">
                        <div class="api-method-signature">
                            <code>domain1 + domain2</code>
                        </div>
                        <p>Union of two domains (set union operation).</p>
                        <pre data-copy><code class="language-python"># Create union of two domains
combined_domain = domain1 + domain2</code></pre>
                    </div>

                    <div class="api-operator">
                        <div class="api-method-signature">
                            <code>domain1 - domain2</code>
                        </div>
                        <p>Difference of two domains (set difference operation).</p>
                        <pre data-copy><code class="language-python"># Subtract domain2 from domain1
difference_domain = domain1 - domain2</code></pre>
                    </div>
                </section>

                <!-- Examples Section -->
                <section id="examples" class="api-section">
                    <h2>Examples</h2>

                    <div class="api-example">
                        <h3>Creating a Domain from STL File</h3>
                        <pre data-copy><code class="language-python">import pyvista as pv
from svv.domain import Domain

# Load STL file
mesh = pv.read('vessel.stl')

# Create domain
domain = Domain(mesh)

# Build implicit function with custom resolution
domain.create()
domain.solve()
domain.build(resolution=30)

# Get mesh statistics
print(f"Domain volume: {domain.volume:.2f}")
print(f"Domain surface area: {domain.area:.2f}")
print(f"Convexity: {domain.convexity:.3f}")</code></pre>
                    </div>

                    <div class="api-example">
                        <h3>Boolean Operations on Domains</h3>
                        <pre data-copy><code class="language-python"># Create two domains
sphere1 = pv.Sphere(center=(0, 0, 0), radius=1.0)
domain1 = Domain(sphere1)
domain1.create()
domain1.solve()
domain1.build()

sphere2 = pv.Sphere(center=(0.5, 0, 0), radius=0.8)
domain2 = Domain(sphere2)
domain2.create()
domain2.solve()
domain2.build()

# Create union (merged domains)
union_domain = domain1 + domain2

# Create difference (domain1 with hole from domain2)
diff_domain = domain1 - domain2

# Evaluate at test points
test_points = np.random.randn(100, 3)
union_values = union_domain(test_points)
diff_values = diff_domain(test_points)</code></pre>
                    </div>

                    <div class="api-example">
                        <h3>Sampling Points with Collision Avoidance</h3>
                        <pre data-copy><code class="language-python">from scipy.spatial import cKDTree

# Create domain
domain = Domain(mesh)
domain.create()
domain.solve()
domain.build()

# Create existing tree structure (e.g., from vessel centerlines)
existing_points = np.array([[0, 0, 0], [1, 0, 0], [0, 1, 0]])
tree = cKDTree(existing_points)

# Sample points avoiding existing structure
new_points, cells = domain.get_interior_points(
    n=1000,
    tree=tree,
    threshold=0.5,  # Minimum distance from existing points
    volume_threshold=5.0  # Maximum distance from existing points
)

# Sample boundary points
boundary_points = domain.get_boundary_points(n=500)</code></pre>
                    </div>
                </section>

                <!-- Notes Section -->
                <section id="notes" class="api-section">
                    <h2>Notes</h2>

                    <div class="admonition note">
                        <p><strong>Implicit Function:</strong> The domain uses radial basis function (RBF) interpolation to create a smooth implicit function representation. Points inside the domain have negative values, points outside have positive values, and the boundary is at the zero level set.</p>
                    </div>

                    <div class="admonition warning">
                        <p><strong>Memory Usage:</strong> For large point clouds or high-resolution meshes, the implicit function construction can be memory-intensive. Consider using lower resolution for initial testing.</p>
                    </div>

                    <div class="admonition info">
                        <p><strong>Performance:</strong> The domain uses optimized Cython routines for point sampling (<code>c_sample.pyx</code>) and allocation (<code>c_allocate.pyx</code>). These provide significant speedups for large-scale operations.</p>
                    </div>

                    <div class="callout tip">
                        <strong>Best Practice:</strong> Always call methods in order: <code>create()</code> → <code>solve()</code> → <code>build()</code> to properly construct the implicit function before using evaluation or sampling methods.
                    </div>
                </section>

                <!-- See Also Section -->
                <section class="api-section">
                    <h2>See Also</h2>
                    <ul>
                        <li><a href="patch.html"><code>svv.domain.Patch</code></a> - Individual patch for RBF interpolation</li>
                        <li><a href="../tree/tree.html"><code>svv.tree.Tree</code></a> - Vascular tree generation using domains</li>
                        <li><a href="../forest/forest.html"><code>svv.forest.Forest</code></a> - Collection of trees within a domain</li>
                    </ul>
                </section>
            </main>

            <!-- Right TOC -->
            <aside class="api-toc-sidebar">
                <div class="sidebar-section">
                    <h4 class="sidebar-title">On This Page</h4>
                    <nav id="local-toc" class="api-local-toc">
                        <!-- Auto-populated by JavaScript -->
                    </nav>
                </div>
            </aside>
        </div>
    </div>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2025 SimVascular, Stanford University, The Regents of the University of California, and others –
            <a href="https://opensource.org/license/BSD-3-Clause">BSD 3-Clause License</a><br></p>
        </div>
    </footer>

    <!-- Additional styles for this page -->
    <style>
        .api-class-header {
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 3px solid var(--clr-primary-400);
        }

        .api-class-header h1 {
            margin: 0;
            font-family: Consolas, monospace;
            color: var(--clr-primary-700);
        }

        .api-badges {
            margin-top: 0.5rem;
            display: flex;
            gap: 0.5rem;
        }

        .api-class-description {
            background: var(--clr-grey-100);
            border-left: 4px solid var(--clr-primary-400);
            padding: 1rem;
            border-radius: var(--radius-sm);
            margin-bottom: 2rem;
        }

        .api-quick-example {
            margin-bottom: 2rem;
        }

        .api-method-group {
            margin-bottom: 2rem;
        }

        .api-method-group h3 {
            color: var(--clr-primary-700);
            border-bottom: 2px solid var(--clr-grey-300);
            padding-bottom: 0.5rem;
            margin-bottom: 1rem;
        }

        .api-method {
            background: var(--clr-surface);
            border: 1px solid var(--clr-grey-300);
            border-radius: var(--radius-sm);
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .api-method-signature {
            background: var(--clr-grey-100);
            padding: 0.5rem 1rem;
            border-radius: var(--radius-sm);
            font-family: Consolas, monospace;
            margin-bottom: 0.75rem;
        }

        .api-method-params h4 {
            color: var(--clr-primary-700);
            font-size: 0.9rem;
            margin-top: 0.75rem;
            margin-bottom: 0.5rem;
        }

        .api-operator {
            background: var(--clr-surface);
            border: 1px solid var(--clr-grey-300);
            border-radius: var(--radius-sm);
            padding: 1rem;
            margin-bottom: 1rem;
        }
    </style>

    <!-- Load Scripts -->
    <script defer src="../script.js"></script>
    <script defer src="script_api.js"></script>
</body>
</html>
