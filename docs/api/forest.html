<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>svv.forest.Forest - svVascularize API</title>
    <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet" />
    <link rel="stylesheet" href="../style.css">
    <link rel="stylesheet" href="style_api.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <!-- Shared top navigation -->
    <header class="topnav">
        <div class="container">
            <h1>svVascularize</h1>
            <nav>
                <a href="../index.html#about">About</a>
                <a href="../install.html">Installation</a>
                <a href="../doc.html">Documentation</a>
                <a href="../index.html#simulation">Simulation</a>
                <a href="https://pypi.org/project/svv/" target="_blank" rel="noopener">PyPI</a>
                <a href="https://github.com/SimVascular/svVascularize" target="_blank" rel="noopener">GitHub</a>
            </nav>
        </div>
    </header>

    <!-- Breadcrumbs -->
    <div class="container">
        <nav class="api-breadcrumbs">
            <a href="../doc.html">Documentation</a>
            <span class="separator">/</span>
            <a href="index_api.html">API Reference</a>
            <span class="separator">/</span>
            <a href="index_api.html#module-forest">svv.forest</a>
            <span class="separator">/</span>
            <span>Forest</span>
        </nav>
    </div>

    <!-- Main Content -->
    <div class="container api-container">
        <!-- Class Header -->
        <div class="api-class-header">
            <h1><code>svv.forest.Forest</code></h1>
            <div class="api-badges">
                <span class="api-module-badge">Core Class</span>
                <span class="api-version-badge">v1.0.0</span>
            </div>
        </div>

        <!-- Class Description -->
        <div class="api-class-description">
            <p>
                The Forest class defines collections of synthetic vascular tree structures that are used to abstract
                the physical representations of generated interpenetrating vascular networks.
            </p>
            <p>
                Forests enable the generation of multiple interconnected vascular networks within the same domain,
                with collision detection between networks, competitive growth patterns, and various connection
                strategies between trees. This is essential for modeling complex multi-network vascular systems
                like arterial-venous networks or competing tumor vasculature.
            </p>
        </div>

        <!-- Quick Example -->
        <div class="api-quick-example">
            <h2>Quick Example</h2>
            <pre data-copy><code class="language-python">from svv.forest.forest import Forest
from svv.domain.domain import Domain
import numpy as np
import pyvista as pv

# Create domain
mesh = pv.read('tissue_region.stl')
domain = Domain(mesh)
domain.create()
domain.solve()
domain.build()

# Initialize forest with 2 networks, 2 trees each
forest = Forest(
    domain=domain,
    n_networks=2,
    n_trees_per_network=[2, 2],
    physical_clearance=0.5,  # mm spacing between vessels
    compete=True  # Enable competition for space
)

# Set domain for all trees
forest.set_domain(domain)

# Define start points for each tree
start_points = [
    [np.array([0, 0, -10]), np.array([0, 0, 10])],  # Network 1
    [np.array([-10, 0, 0]), np.array([10, 0, 0])]   # Network 2
]
forest.set_roots(start_points)

# Grow networks
forest.add(100)  # Add 100 vessels to each tree

# Connect trees within networks (start with cubic curves)
forest.connect(3)

# Visualize
forest.show(plot_domain=True)</code></pre>
        </div>

        <!-- Main Documentation Grid -->
        <div class="api-grid">
            <!-- Left Navigation -->
            <aside class="api-sidebar">
                <div class="sidebar-section">
                    <h4 class="sidebar-title">Contents</h4>
                    <nav class="api-sidebar-nav">
                        <ul>
                            <li><a href="#constructor"><i class="fas fa-hammer"></i> Constructor</a></li>
                            <li><a href="#attributes"><i class="fas fa-database"></i> Attributes</a></li>
                            <li><a href="#setup-methods"><i class="fas fa-cog"></i> Setup Methods</a></li>
                            <li><a href="#growth-methods"><i class="fas fa-seedling"></i> Growth Methods</a></li>
                            <li><a href="#connection-methods"><i class="fas fa-link"></i> Connection Methods</a></li>
                            <li><a href="#export-methods"><i class="fas fa-file-export"></i> Export Methods</a></li>
                            <li><a href="#persistence"><i class="fas fa-save"></i> Persistence</a></li>
                            <li><a href="#examples"><i class="fas fa-code"></i> Examples</a></li>
                            <li><a href="#algorithms"><i class="fas fa-brain"></i> Algorithms</a></li>
                        </ul>
                    </nav>
                </div>
            </aside>

            <!-- Main Content -->
            <main class="api-main-content">
                <!-- Constructor Section -->
                <section id="constructor" class="api-section">
                    <h2>Constructor</h2>

                    <div class="api-signature">
                        <code>Forest(**kwargs)</code>
                    </div>

                    <div class="api-parameters">
                        <h3>Parameters</h3>
                        <table class="api-table">
                            <thead>
                                <tr>
                                    <th>Parameter</th>
                                    <th>Type</th>
                                    <th>Default</th>
                                    <th>Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>domain</code></td>
                                    <td>Domain</td>
                                    <td>None</td>
                                    <td>Spatial domain for tree generation</td>
                                </tr>
                                <tr>
                                    <td><code>n_networks</code></td>
                                    <td>int</td>
                                    <td>1</td>
                                    <td>Number of vascular networks</td>
                                </tr>
                                <tr>
                                    <td><code>n_trees_per_network</code></td>
                                    <td>list[int]</td>
                                    <td>[2]</td>
                                    <td>Number of trees in each network</td>
                                </tr>
                                <tr>
                                    <td><code>start_points</code></td>
                                    <td>list[np.ndarray]</td>
                                    <td>None</td>
                                    <td>Starting points for each tree</td>
                                </tr>
                                <tr>
                                    <td><code>directions</code></td>
                                    <td>list[np.ndarray]</td>
                                    <td>None</td>
                                    <td>Initial directions for each tree</td>
                                </tr>
                                <tr>
                                    <td><code>physical_clearance</code></td>
                                    <td>float</td>
                                    <td>0.0</td>
                                    <td>Minimum spacing between vessels (mm)</td>
                                </tr>
                                <tr>
                                    <td><code>compete</code></td>
                                    <td>bool</td>
                                    <td>False</td>
                                    <td>Enable competition for space between networks</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </section>

                <!-- Attributes Section -->
                <section id="attributes" class="api-section">
                    <h2>Attributes</h2>

                    <table class="api-table">
                        <thead>
                            <tr>
                                <th>Attribute</th>
                                <th>Type</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>networks</code></td>
                                <td>list[list[Tree]]</td>
                                <td>2D list of Tree objects organized by network</td>
                            </tr>
                            <tr>
                                <td><code>connections</code></td>
                                <td>ForestConnection</td>
                                <td>Connection manager for inter-tree links</td>
                            </tr>
                            <tr>
                                <td><code>domain</code></td>
                                <td>Domain</td>
                                <td>Spatial domain constraining all trees</td>
                            </tr>
                            <tr>
                                <td><code>n_networks</code></td>
                                <td>int</td>
                                <td>Number of separate networks</td>
                            </tr>
                            <tr>
                                <td><code>n_trees_per_network</code></td>
                                <td>list[int]</td>
                                <td>Tree count for each network</td>
                            </tr>
                            <tr>
                                <td><code>geodesic</code></td>
                                <td>callable</td>
                                <td>Geodesic path constructor for connections</td>
                            </tr>
                            <tr>
                                <td><code>convex</code></td>
                                <td>bool</td>
                                <td>Whether domain is convex</td>
                            </tr>
                            <tr>
                                <td><code>physical_clearance</code></td>
                                <td>float</td>
                                <td>Inter-vessel spacing constraint</td>
                            </tr>
                            <tr>
                                <td><code>compete</code></td>
                                <td>bool</td>
                                <td>Competition mode flag</td>
                            </tr>
                        </tbody>
                    </table>
                </section>

                <!-- Setup Methods Section -->
                <section id="setup-methods" class="api-section">
                    <h2>Setup Methods</h2>

                    <div class="api-method">
                        <div class="api-method-signature">
                            <code>set_domain(domain, convexity_tolerance=1e-2)</code>
                        </div>
                        <p>Set the spatial domain for all trees in the forest.</p>
                        <div class="api-method-params">
                            <h4>Parameters</h4>
                            <ul>
                                <li><code>domain</code> (Domain): Domain object defining growth region</li>
                                <li><code>convexity_tolerance</code> (float): Tolerance for convexity determination</li>
                            </ul>
                            <h4>Notes</h4>
                            <p>Automatically initializes geodesic path constructor and propagates domain to all trees.</p>
                        </div>
                    </div>

                    <div class="api-method">
                        <div class="api-method-signature">
                            <code>set_roots(*args, **kwargs)</code>
                        </div>
                        <p>Set root vessels for all trees with collision detection.</p>
                        <div class="api-method-params">
                            <h4>Parameters</h4>
                            <ul>
                                <li><code>start_points</code> (list): 2D list of starting points [network][tree]</li>
                                <li><code>directions</code> (list, optional): 2D list of initial directions</li>
                            </ul>
                            <h4>Algorithm</h4>
                            <p>Iteratively places roots while checking for collisions between all previously placed roots.
                            Retries placement if collision is detected.</p>
                        </div>
                    </div>
                </section>

                <!-- Growth Methods Section -->
                <section id="growth-methods" class="api-section">
                    <h2>Growth Methods</h2>

                    <div class="api-method">
                        <div class="api-method-signature">
                            <code>add(n_vessels=1, decay_probability=0.9, network_id=None, **kwargs)</code>
                        </div>
                        <p>Add vessels to trees with inter-network collision detection.</p>
                        <div class="api-method-params">
                            <h4>Parameters</h4>
                            <ul>
                                <li><code>n_vessels</code> (int): Number of vessels to add to each tree</li>
                                <li><code>decay_probability</code> (float): Probability decay for space competition</li>
                                <li><code>network_id</code> (list, optional): Specific networks to grow (default: all)</li>
                                <li><code>progress</code> (bool): Show progress bar</li>
                            </ul>
                            <h4>Algorithm</h4>
                            <p>For each vessel addition:</p>
                            <ol>
                                <li>Attempt vessel placement in each tree</li>
                                <li>Check for collisions with all other trees</li>
                                <li>Roll back changes if collision detected</li>
                                <li>Retry until successful placement</li>
                                <li>Update spatial indices and probabilities</li>
                            </ol>
                        </div>
                    </div>
                </section>

                <!-- Connection Methods Section -->
                <section id="connection-methods" class="api-section">
                    <h2>Connection Methods</h2>

                    <div class="api-method">
                        <div class="api-method-signature">
                            <code>connect(*args, **kwargs)</code>
                        </div>
                        <p>Create connections between trees within each network.</p>
                        <div class="api-method-params">
                            <h4>Usage</h4>
                            <ul>
                                <li><code>forest.connect()</code>: start with linear connections</li>
                                <li><code>forest.connect(3)</code>: start optimization with cubic curves</li>
                                <li><code>forest.connect(curve_type='NURBS')</code>: switch curve family</li>
                            </ul>
                            <h4>Notes</h4>
                            <p>The method instantiates a <code>ForestConnection</code> that orchestrates
                            <code>TreeConnection</code> and <code>VesselConnection</code> objects to build
                            collision-free connecting vessels.</p>
                        </div>
                    </div>
                </section>

                <!-- Export Methods Section -->
                <section id="export-methods" class="api-section">
                    <h2>Export Methods</h2>

                    <div class="api-method">
                        <div class="api-method-signature">
                            <code>export_solid(outdir=None, shell_thickness=0.0)</code>
                        </div>
                        <p>Export all trees as 3D solid models.</p>
                        <div class="api-method-params">
                            <h4>Parameters</h4>
                            <ul>
                                <li><code>outdir</code> (str, optional): Output directory (default: '3d_tmp')</li>
                                <li><code>shell_thickness</code> (float): Wall thickness for hollow vessels</li>
                            </ul>
                            <h4>Notes</h4>
                            <p>Exports each tree individually. Files are named by network and tree indices.</p>
                        </div>
                    </div>

                    <div class="api-method">
                        <div class="api-method-signature">
                            <code>show(**kwargs)</code>
                        </div>
                        <p>Visualize the entire forest with PyVista.</p>
                        <div class="api-method-params">
                            <h4>Parameters</h4>
                            <ul>
                                <li><code>colors</code> (list[str], optional): Cycle of colors for each tree</li>
                                <li><code>plot_domain</code> (bool): Overlay the domain boundary (default: False)</li>
                                <li><code>return_plotter</code> (bool): Return the PyVista plotter instead of showing</li>
                                <li><code>**kwargs</code>: Additional PyVista plotting parameters</li>
                            </ul>
                        </div>
                    </div>
                </section>

                <!-- Persistence Section -->
                <section id="persistence" class="api-section">
                    <h2>Persistence (Save/Load)</h2>

                    <p>Forests can be saved to and loaded from <code>.forest</code> files, enabling checkpointing during
                    complex multi-tree growth processes and sharing of generated vascular networks.</p>

                    <div class="api-method">
                        <div class="api-method-signature">
                            <code>save(path, include_timing=False)</code>
                        </div>
                        <p>Save the forest to a <code>.forest</code> file.</p>
                        <div class="api-method-params">
                            <h4>Parameters</h4>
                            <ul>
                                <li><code>path</code> (str): Output filename. If no extension is provided, <code>.forest</code> is appended.</li>
                                <li><code>include_timing</code> (bool): Include generation timing data for each tree. Default is False.</li>
                            </ul>
                            <h4>Returns</h4>
                            <ul>
                                <li><code>pathlib.Path</code>: Path to the saved file.</li>
                            </ul>
                            <h4>Notes</h4>
                            <p>The saved file contains all forest data, tree parameters, and connectivity information.
                            If <code>connect()</code> has been called, connections are also saved. <strong>The domain
                            is NOT saved</strong> and must be set separately after loading via <code>set_domain()</code>.</p>
                        </div>
                    </div>

                    <div class="api-method">
                        <div class="api-method-signature">
                            <code>Forest.load(path)</code>  <span class="api-badge">classmethod</span>
                        </div>
                        <p>Load a forest from a <code>.forest</code> file.</p>
                        <div class="api-method-params">
                            <h4>Parameters</h4>
                            <ul>
                                <li><code>path</code> (str): Path to a <code>.forest</code> file.</li>
                            </ul>
                            <h4>Returns</h4>
                            <ul>
                                <li><code>Forest</code>: Loaded forest instance with all trees and connections restored.</li>
                            </ul>
                            <h4>Notes</h4>
                            <p>The loaded forest will NOT have a domain set. You must call <code>set_domain()</code>
                            after loading to enable domain-dependent operations. If the forest was saved with
                            connections (after calling <code>connect()</code>), those connections are restored.</p>
                        </div>
                    </div>

                    <div class="api-example">
                        <h4>Save/Load Example</h4>
                        <pre data-copy><code class="language-python">from svv.forest.forest import Forest
from svv.domain.domain import Domain
import pyvista as pv

# Create and grow a forest
domain = Domain(pv.Cube())
domain.create()
domain.solve()
domain.build()

forest = Forest()
forest.set_domain(domain)
forest.set_roots()  # Uses default opposing start points
forest.add(50)
forest.connect()

# Save the complete forest (including connections)
forest.save("vascular_network.forest")

# Later, load it back
loaded_forest = Forest.load("vascular_network.forest")

# Re-attach the domain
loaded_forest.set_domain(domain)

# Connections are preserved - can visualize immediately
loaded_forest.show(plot_domain=True)

# Or continue growing
loaded_forest.add(25)</code></pre>
                    </div>

                    <div class="callout info">
                        <strong>Connections Preserved:</strong> Unlike trees, forests can include connection data when
                        saved. If you saved after calling <code>connect()</code>, the connection geometry and parameters
                        are restored on load.
                    </div>
                </section>

                <!-- Examples Section -->
                <section id="examples" class="api-section">
                    <h2>Examples</h2>

                    <div class="api-example">
                        <h3>Arterial-Venous Network</h3>
                        <pre data-copy><code class="language-python">from svv.forest.forest import Forest
from svv.domain.domain import Domain
import numpy as np
import pyvista as pv

# Create organ domain
organ = pv.read('liver.stl')
domain = Domain(organ)
domain.create()
domain.solve()
domain.build(resolution=40)

# Create forest with arterial and venous networks
forest = Forest(
    domain=domain,
    n_networks=2,  # Arterial and venous
    n_trees_per_network=[1, 1],
    physical_clearance=1.0  # 1mm minimum spacing
)

# Set inlet/outlet points
arterial_inlet = np.array([0, 0, -50])
venous_outlet = np.array([0, 0, 50])

forest.set_roots(
    start_points=[[arterial_inlet], [venous_outlet]],
    directions=[[np.array([0, 0, 1])], [np.array([0, 0, -1])]]
)

# Grow networks with competition
for i in range(200):
    forest.add(1)
    if i % 50 == 0:
        print(f"Step {i}: Arterial terminals: {forest.networks[0][0].n_terminals}, "
              f"Venous terminals: {forest.networks[1][0].n_terminals}")

# Connect within networks if multiple trees
forest.connect(3)

# Visualize with different colors
forest.show(colors=['red', 'blue'], plot_domain=True)</code></pre>
                    </div>

                    <div class="api-example">
                        <h3>Multi-Tree Network with Connections</h3>
                        <pre data-copy><code class="language-python">from svv.forest.forest import Forest
import numpy as np
# Create forest with multiple trees per network
forest = Forest(
    n_networks=1,
    n_trees_per_network=[4],  # 4 trees in single network
    physical_clearance=0.5
)

# Set domain
forest.set_domain(domain)

# Place trees at corners
corners = [
    np.array([-10, -10, 0]),
    np.array([10, -10, 0]),
    np.array([10, 10, 0]),
    np.array([-10, 10, 0])
]

forest.set_roots(start_points=[corners])

# Grow trees
forest.add(50)

# Create inter-tree connections
forest.connect(5)  # Higher degree for smoother connections

# Access connection data
if forest.connections:
    print(f"Tree connections solved: {len(forest.connections.tree_connections)}")

# Export connected network: save each tree as STL
for i in range(forest.n_networks):
    for j in range(forest.n_trees_per_network[i]):
        model = forest.networks[i][j].export_solid(watertight=True)
        model.save(f'connected_network_{i}_{j}.stl')</code></pre>
                    </div>

                    <div class="api-example">
                        <h3>Competitive Growth Pattern</h3>
                        <pre data-copy><code class="language-python"># Enable competition between networks
from svv.forest.forest import Forest
import numpy as np
forest = Forest(
    domain=domain,
    n_networks=3,  # Three competing networks
    n_trees_per_network=[1, 1, 1],
    physical_clearance=0.1,
    compete=True  # Enable competition
)

# Set starting points
starts = [
    [np.array([0, -20, 0])],    # Network 1
    [np.array([17, 10, 0])],    # Network 2
    [np.array([-17, 10, 0])]    # Network 3
]

forest.set_roots(start_points=starts)

forest.add(50)

# Analyze competition results
import matplotlib.pyplot as plt
# Track terminal counts over time
terminal_history = []
for _ in range(50):
    forest.add(1)
    terminal_history.append([forest.networks[i][0].n_terminals for i in range(3)])

terminal_history = np.array(terminal_history)
for i in range(terminal_history.shape[1]):
    plt.plot(terminal_history[:, i], label=f'Network {i}')
plt.xlabel('Growth Step')
plt.ylabel('Number of Terminals')
plt.legend()
plt.title('Competitive Growth Dynamics')
plt.show()</code></pre>
                    </div>
                </section>

                <!-- Algorithms Section -->
                <section id="algorithms" class="api-section">
                    <h2>Algorithms</h2>

                    <div class="admonition info">
                        <p><strong>Collision Detection:</strong> The Forest class implements comprehensive collision detection
                        between all trees during growth. Each new vessel is checked against all existing vessels in other
                        trees, with automatic rollback on collision detection.</p>
                    </div>

                    <div class="admonition note">
                        <p><strong>Space Sampling:</strong> When sampling space for new terminal selection the probability
                        that a region which has been previously sampled is drawn again for another terminal decays by the
                        indicated value to encourage the vascular growth into unvisited territories.</p>
                    </div>

                    <div class="admonition warning">
                        <p><strong>Performance:</strong> Growth complexity is O(n²m) where n is the number of trees and m
                        is vessels per tree. For large forests, consider growing networks sequentially or using parallel
                        processing for collision checks.</p>
                    </div>

                    <h3>Connection Algorithms</h3>
                    <p>The forest supports multiple connection strategies:</p>
                    <ul>
                        <li><strong>Bezier:</strong> Smooth polynomial curves of specified degree</li>
                        <li><strong>NURBS:</strong> Non-uniform rational B-splines for precise control</li>
                        <li><strong>Geodesic:</strong> Shortest paths along the domain surface</li>
                        <li><strong>Catmull-Rom:</strong> Interpolating splines through control points</li>
                    </ul>
                </section>

                <!-- See Also Section -->
                <section class="api-section">
                    <h2>See Also</h2>
                    <ul>
                        <li><a href="tree.html"><code>svv.tree.Tree</code></a> - Individual tree structure</li>
                        <li><a href="domain.html"><code>svv.domain.Domain</code></a> - Spatial domains</li>
                        <!--<li><a href="forest_connection.html"><code>svv.forest.ForestConnection</code></a> - Connection manager</li>
                        <li><a href="geodesic.html"><code>svv.forest.connect.geodesic</code></a> - Geodesic path algorithms</li> -->
                    </ul>
                </section>
            </main>

            <!-- Right TOC -->
            <aside class="api-toc-sidebar">
                <div class="sidebar-section">
                    <h4 class="sidebar-title">On This Page</h4>
                    <nav id="local-toc" class="api-local-toc">
                        <!-- Auto-populated by JavaScript -->
                    </nav>
                </div>
            </aside>
        </div>
    </div>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2025 SimVascular, Stanford University, The Regents of the University of California, and others –
            <a href="https://opensource.org/license/BSD-3-Clause">BSD 3-Clause License</a><br></p>
        </div>
    </footer>

    <!-- Additional styles for this page -->
    <style>
        .api-class-header {
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 3px solid var(--clr-primary-400);
        }

        .api-class-header h1 {
            margin: 0;
            font-family: Consolas, monospace;
            color: var(--clr-primary-700);
        }

        .api-badges {
            margin-top: 0.5rem;
            display: flex;
            gap: 0.5rem;
        }

        .api-class-description {
            background: var(--clr-grey-100);
            border-left: 4px solid var(--clr-primary-400);
            padding: 1rem;
            border-radius: var(--radius-sm);
            margin-bottom: 2rem;
        }

        .api-method {
            background: var(--clr-surface);
            border: 1px solid var(--clr-grey-300);
            border-radius: var(--radius-sm);
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .api-method-signature {
            background: var(--clr-grey-100);
            padding: 0.5rem 1rem;
            border-radius: var(--radius-sm);
            font-family: Consolas, monospace;
            margin-bottom: 0.75rem;
        }

        .api-method-params h4 {
            color: var(--clr-primary-700);
            font-size: 0.9rem;
            margin-top: 0.75rem;
            margin-bottom: 0.5rem;
        }
    </style>

    <!-- Load Scripts -->
    <script defer src="../script.js"></script>
    <script defer src="script_api.js"></script>
</body>
</html>
